% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mgks.R
\name{mgks}
\alias{mgks}
\title{Multivariate Gaussian kernel smoother and its derivatives}
\usage{
mgks(y, X, X0, beta, deriv = 0)
}
\description{
Multivariate Gaussian kernel smoother and its derivatives
}
\examples{
### Example
# Simulate values of 2D function
n <- 1000
X0 <- cbind(runif(n, -1, 1), runif(n, -4, 4))
trueF <- function(x) 3 * x[ , 1] + x[ , 2]^2
y <- trueF(X0)

# Evaluate kernel smooth on a grid
ngr <- 40
xseq1 <- seq(-1, 1, length.out = ngr)
xseq2 <- seq(-4, 4, length.out = ngr)
X <- as.matrix(expand.grid(xseq1, xseq2))

# Here beta[j] is log(1 / sigma[j]) where sigma is standard deviation
beta <- c(log(20), log(5))
fit <- mgks(y = y, X = X, X0 = X0, beta = beta, deriv = 0)

par(mfrow = c(2, 1))
image(x = xseq1, y = xseq2, z = matrix(fit$d0, ngr, ngr), main = "Estimated")
image(x = xseq1, y = xseq2, z = matrix(trueF(X), ngr, ngr), main = "Truth")

### Checking derivatives by finite differences

# Simulate values of 3D function
n <- 1000
X0 <- cbind(runif(n, -1, 1), runif(n, -4, 4), runif(n, -2, 2))
trueF <- function(x) 3 * x[ , 1] + x[ , 2]^2 - 0.5 * x[ , 3]^2
y <- trueF(X0)
# Define grid over which derivative will be evaluated
ngr <- 5
xseq1 <- seq(-1, 1, length.out = ngr)
xseq2 <- seq(-4, 4, length.out = ngr)
xseq3 <- seq(-2, 2, length.out = ngr)
X <- as.matrix(expand.grid(xseq1, xseq2, xseq3))

# Wrap derivatives for compatibility with gamFactory::checkDeriv
obj <- list(d0 = function(param){
  sum(mgks(y = y, X = X, X0 = X0, beta = param, deriv = 0)$d0)
},
d1 = function(param){
  tmp <- colSums(mgks(y = y, X = X, X0 = X0, beta = param, deriv = 1)$d1)
  as.list(tmp)
},
d2 = function(param){
  tmp <- colSums(mgks(y = y, X = X, X0 = X0, beta = param, deriv = 2)$d2)
  as.list(tmp)
},
d3 = function(param){
  tmp <- colSums(mgks(y = y, X = X, X0 = X0, beta = param, deriv = 3)$d3)
  as.list(tmp)
})

# Check derivatives up to order 3
beta <- c(log(10), log(5), log(5))
(tmp <- checkDeriv(obj = obj, param = beta, ord = 1:3))

par(mfrow = c(2, 2))
for(ii in 1:3){
 plot(tmp[[ii]][ , 2], tmp[[ii]][ , 1] - tmp[[ii]][ , 2],
      main = paste0("mgks deriv ", ii), ylab = "Error",
      xlab = "Deriv value")
 abline(h = 0)
}

}
