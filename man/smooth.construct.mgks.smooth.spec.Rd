% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smooth_construct_mgks_smooth_spec.R
\name{smooth.construct.mgks.smooth.spec}
\alias{smooth.construct.mgks.smooth.spec}
\title{Nested MGKS effects for mgcv}
\usage{
\method{smooth.construct}{mgks.smooth.spec}(object, data, knots)
}
\arguments{
\item{object}{A \code{smooth.spec} object containing details about the smooth term generated by a term \code{s_nest(...)}.
It includes distance matrices and response variables.}

\item{data}{A data frame containing variables required for smoothing, including:
\itemize{
\item \code{y}: Response variable to be smoothed.
\item \code{d}: Pairwise distance matrices.
}}

\item{knots}{A list specifying knots for constructing the outer B-spline basis.}
}
\value{
A \code{"mgks"} and \code{"nested"} object.
}
\description{
This function implements the nested Multivariate Gaussian Kernel Smoothing (MGKS) effects.
MGKS is designed to handle spatially misaligned data by smoothing observations at distinct
locations using their pairwise distances.
The \code{mgks} is formally defined as follows. Let \eqn{{z}_{ij}} represent a scalar covariate associated with the vector \eqn{{x}_{ij}}. For example, \eqn{{z}_{ij}} could represent the temperature at time \eqn{i}, while \eqn{{x}_{ij}} might indicate the longitude and latitude of the observation location.

The kernel smoothing estimation of \eqn{z_i} at position \eqn{{x}_i} is computed as:
\deqn{s~({x}_i) = \frac{\sum_{j=1}^{n_j}K_{{a}}({x}_{i}, {{x}}_{ij})z_{ij}}{\sum_{q=1}^{n_j}K_{{a}}({x}_{i},{{x}}_{iq})},}
where \eqn{K_{a}} is a kernel function from a multivariate probability density, parameterized by the vector \eqn{{a}}.

In general \eqn{{x}_i} does not necessarily belong to the set \eqn{({x}_{i1}, \ldots, {x}_{in_j})}. This flexibility of \eqn{s~} makes it especially useful in cases of misaligned covariates, where the covariate measurements are taken at locations different from the sites of the response variable.
}
\examples{
n0 <- 50;n <- 1000
X0 <- cbind(runif(n0, -1, 1), runif(n0, -4, 4))
X <- cbind(runif(n, -1, 1), runif(n, -4, 4))
dist <- lapply(1:ncol(X), function(dd){
  t(sapply(1:nrow(X), function(ii) (X[ii, dd] - X0[ , dd])^2 ))
})
dist <- dist[[1]] + dist[[2]]
trueF <- function(x) 3 * x[ , 1] + x[ , 2]^2
temp <- t(sapply(1:n, function(ii) trueF(X0)))

z.mgks <- trueF(X)
dat <- data.frame(y = z.mgks*cos(z.mgks/2)+rnorm(n))
dat$Xks <- cbind(temp,dist)
colnames(dat$Xks) <- c(rep("y", nrow(X0)), rep("d1", nrow(X0)))
aaa <- smoothCon(s_nest(Xks, trans=trans_mgks(), m = c(4, 2)),data = dat)

}
\seealso{
\code{\link{mgks}, \code{\link{trans_mgks}}}
}
