---
title: "gamFactory: tool for building GAM models in mgcv"
author: "Matteo Fasiolo"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    number_sections: true
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{mgcViz_vignette}
  %\VignetteEncoding{UTF-8}
---

<style>
body {
text-align: justify}
</style>

```{r setup, include=FALSE}
library(knitr)
library(rgl)
opts_chunk$set(out.extra='style="display:block; margin: auto"', fig.align="center", tidy=FALSE)
knit_hooks$set(webgl = hook_webgl)
```


# Testing derivatives of response family

As an example I consider the Generalized Pareto Distribution. We first create the family:
```{r 1, message = F}
library(gamFactory)

n <- 1000
pars <- c(rnorm(1, 0, 1), 1e-2 + rexp(1, 1), rexp(1, 1))
obj <- createGPD( )$initialize(n, pars)
```
The parameters have been randomly simulated, and `n=1000` observations are simulated via `createGPD( )$initialize`. Now we compare exact (`EX`) and finite difference (`FD`) derivative of up to order 3 at the fixed parameters: 
```{r 2, message = F}
fdDeriv(obj = derFunWrapper(obj$derObj), 
        param = pars, 
        ord = 1:3)
```

Now we do a more systematic check, by simulating `np` vectors of parameters from `parSim` and checking the derivatives at each:
```{r 3, message = F}
der <- derivCheck(np = 100, 
                  parSim = function(n){ cbind(rnorm(n), 1 + rexp(n, 1), rexp(n, 1)) }, 
                  obj = obj,
                  ord = 1:3, 
                  trans = function(.x){
                    si <- sign(.x)
                    return( si * sqrt(abs(.x)) )
                  }, 
                  n = 100)
```
Plotting the difference between the analytic and finite-difference derivatives is also useful:
```{r 4, message = F}
par(mfrow = c(2, 2))
for(ii in 1:3) { plot(der[[ii]][ , 1] - der[[ii]][ , 2]) }
```

# Testing derivatives of a non-linear effect

Here we consider an effect of the type
$$
\eta = \sum_{j}\alpha_{j}(z_{i})x_{ij}
$$
where 
$$
\alpha_{1}(z)=\frac{1}{1+\sum_{j\neq1}\exp(\nu_{j})}, \;\;\;\;
\alpha_{k}(z)=\frac{\exp(\nu_{k})}{1+\sum_{j\neq1}\exp(\nu_{j})},\;\;\;\text{for}\;\;\;k=2,\dots,K,
$$
so that $\sum_{j}\alpha_{j}(z_{i})=1$. To create such an effect we do
```{r a1, message = F}
library(gamFactory)

K <- 5
alpha0 <- rnorm(K - 1) 
obj <- createStackEffect( )$initialize(d = K)
```
Then we check the first three derivatives at $alpha0$:
```{r a2, message = F}
fdDeriv(obj = derFunWrapper(obj$derObj, dropHessian = TRUE), 
        param = alpha0, 
        ord = 1:3)
```
Looks good. Now we do some more serious testing:
```{r a3, message = F}
der <- derivCheck(np = 100, 
                  parSim = function(n){ matrix(rnorm(n*(K-1)), n, K-1) }, 
                  obj = obj,
                  ord = 1:3, 
                  trans = function(.x){
                    si <- sign(.x)
                    return( si * sqrt(abs(.x)) )
                  }, 
                  d = K)
```
Different way of plotting:
```{r a4, message = F}
par(mfrow = c(2, 2))
for(ii in 1:3) { plot(der[[ii]][ , 1] - der[[ii]][ , 2]) }
```
