---
title: "Stacking probabilistic forecasts of electricity load with smart meter data"
author: "Matteo Fasiolo"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{stacking}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Let us fit two experts on the `UKload` dataset in the `qgam` package. 
The `summer` expert is fitted using only summer data, the `winter` expert one is fitted using winter data.
The two experts are additive models, with Gaussian response. 
For comparison purpose, we propose the `all` model, which uses all the data.
The formula for both models is the one used in the `qgam` vignette.

```{r, message = FALSE}
library(gamFactory)
library(qgam)
library(scoringRules)
data("UKload")

form <- NetDemand~s(wM,k=20,bs='cr') + s(wM_s95,k=20,bs='cr') + 
  s(Posan,bs='ad',k=30,xt=list("bs"="cc")) + Dow + s(Trend,k=4) + NetDemand.48 + Holy

modSummer <- gam(form, data = UKload[UKload$Posan >= .25 & UKload$Posan <= .75, ])
modWinter <- gam(form, data = UKload[UKload$Posan < .25 | UKload$Posan > .75, ])
modAll <- gam(form, data = UKload)
```

For each expert and the `all` model, let us calculate the log-predictive distribution on the whole dataset, as the log-density of the normal distribution at the response variable value, with mean and standard deviation estimated by the additive model.

```{r}
muAll <- predict(modAll)
sdAll <- modAll$sig2 ^ .5
allLogP <- dnorm(UKload$NetDemand, muAll, sdAll, log = TRUE)

muSummer <- predict(modSummer, newdata = UKload)
sdSummer <- modSummer$sig2 ^ .5
summerLogP <- dnorm(UKload$NetDemand, muSummer, sdSummer, log = TRUE)

muWinter <- predict(modWinter, newdata = UKload)
sdWinter <- modWinter$sig2 ^ .5
winterLogP <- dnorm(UKload$NetDemand, muWinter, sdWinter, log = TRUE)

logP <- cbind(summerLogP, winterLogP)
```

The matrix `logP` contains the log-predictive densities of the two experts, which can be aggregated through the stacking.
The weights of the stacking are allowed to vary with `Posan`. 
We expect that the model fitted on summer data is selected during the summer, while the model fitted on the winter data is selected during the winter.

```{r}
## Note: you need a list even with a single linear predictor!!
formStacking <- list(NetDemand ~ s(Posan, k = 20, bs = "cr"))

modStacking <- gam(
  formula = formStacking,
  data = UKload,
  family = stackPredictiveFamily(logP)
)
```

After the stacking model has been fitted, we can calculate the weights of the stacking for each observation.
While we can use `plot(modStacking)` to see the covariate effect on the linear predictor scale, interpretation of such plots is not immediate. 
In this simple case (with one covariate) we can plot weights as function of the covariate `Posan`.

```{r}
nuHat <- cbind(0, predict(modStacking))
## if you do exp of large numbers you could get Inf
nuCen <- nuHat - rowMaxs(nuHat)
aHat <- exp(nuCen) / rowSums(exp(nuCen))
colnames(aHat) <- c("weightSummer", "weightWinter")

df <- data.frame(Posan = UKload$Posan, aHat)
df <- df[order(df$Posan), ]

with(df, plot(Posan, weightSummer, type = "l"))
with(df, plot(Posan, weightWinter, type = "l"))
```

Note that here plotting the smooth effect on $(0,1)$ scale is straightforward because there is only one covariate. 
With more covariates, we need to use alternative ways such as accumulated local effect plots.

Now let us compare the stacking model against the single experts.
We can use:
  
  * log-score (the one used as loss function to estimate the stacking model)
* pinball loss
* continuous ranked probability score (CRPS)
* square loss

Log-score
```{r}
stackingLogP <- log(rowSums(exp(logP) * aHat))

## log-score
colMeans(cbind(logP, stackingLogP, allLogP))
```

In order to evaluate the pinball and CRPS losses on the stacking model, we need the aggregated predictive distribution, which is a mixture of normals.
We can obtain it by simulation.


```{r}
## pinball loss
quantiles <- c(.01, .05, .25, .5, .75, .9, .95, .99)

set.seed(123)
nsim <- 1e4
rn <- rnorm(1e4)

qStacking <- crpsStacking <- muStacking <- list()
coun <- 0
for (ii in 1:nrow(UKload)) {
  coun <- coun + 1
  rSummer <- rn * sdSummer + muSummer[ii]
  rWinter <- rn * sdWinter + muWinter[ii]
  
  rmult <- t(rmultinom(nsim, size = 1, prob = aHat[ii, ]))
  
  rStacking <- numeric(nsim)
  rStacking[rmult[, 1] == 1] <- rSummer[rmult[, 1] == 1]
  rStacking[rmult[, 2] == 1] <- rWinter[rmult[, 2] == 1]
  ## pinball loss
  qStacking[[coun]] <- quantile(rStacking, quantiles)
  ## crps_sample calculates crps score on the basis of random sample
  crpsStacking[[coun]] <- crps_sample(UKload$NetDemand[ii], rStacking)
  ## need mean for square loss
  muStacking[[coun]] <- mean(rStacking)
}
qStacking <- do.call(rbind, qStacking)
crpsStacking <- do.call(rbind, crpsStacking)
muStacking <- do.call(c, muStacking)

pinLossStacking <- sapply(1:length(quantiles), function (ii) {
  pinLoss(UKload$NetDemand, qStacking[, ii], quantiles[ii])
})

pinLossSummer <- sapply(quantiles, function (qq) {
  qSummer <- qnorm(qq, mean = muSummer, sd = sdSummer)
  pinLoss(UKload$NetDemand, qSummer, qq)
})

pinLossWinter <- sapply(quantiles, function (qq) {
  qWinter <- qnorm(qq, mean = muWinter, sd = sdWinter)
  pinLoss(UKload$NetDemand, qWinter, qq)
})

pinAll <- sapply(quantiles, function (qq) {
  qAll <- qnorm(qq, mean = muAll, sd = sdAll)
  pinLoss(UKload$NetDemand, qAll, qq)
})

cbind(quantiles, pinLossSummer, pinLossWinter, pinLossStacking, pinAll)

## crps
colMeans(
  data.frame(
    summer = crps_norm(UKload$NetDemand, muSummer, sdSummer),
    winter = crps_norm(UKload$NetDemand, muWinter, sdWinter),
    stacking = crpsStacking,
    all = crps_norm(UKload$NetDemand, muAll, sdAll)
  )
)

## square loss
c("summer" = mean((UKload$NetDemand - muSummer) ^ 2),
  "winter" = mean((UKload$NetDemand - muWinter) ^ 2),
  "stacking" = mean((UKload$NetDemand - muStacking) ^ 2),
  "all" = mean((UKload$NetDemand - muAll) ^ 2))
```


The stacking outperforms the alternative methods in all the scores.
